=== Creating a Plugin
An apiman plugin is basically a java web archive (WAR) with a little bit of extra
sauce.  This approach makes it very easy to build using maven, and should be quite
familiar to most Java developers.  Because a plugin consists of some resources files,
compiled java classes, front-end resource such as HTML and javascript, and dependencies
in the form of JARs, the WAR format is a natural choice.

==== The Plugin Specification File
In addition to the standard layout of a Java Web Archive, an apiman plugin must contain
the following plugin specification file (which contains information about the plugin):

```
META-INF/apiman/plugin.json
```

This 'plugin.json' file contains the basic meta-data that describes the plugin, and
should be of the following format:

```json
{
  "frameworkVersion" : 1.0,
  "name" : "Plugin Name",
  "description" : "A plugin description goes here.",
  "version" : "3.1.9"
}
```

* *frameworkVersion*: Indicates the apiman plugin framework version this plugin is compatible with - this should simply be 1.0 for now (reserved for future use)
* *name*: The name of the plugin.
* *description*: The description of the plugin.
* *version*: The plugin version.

If this 'plugin.json' file is missing from the plugin archive, then the plugin will
fail to load.

==== Using Maven to Create a Plugin
One benefit of using WAR as the format of an apiman plugin is that plugins can easily
be created using Maven.  This section will describe how this can be done.  Note that
you can use the following simple plugin as a reference if you prefer:

https://github.com/apiman/apiman-plugins/tree/master/noop-policy

In order to create an apiman plugin using maven, simply create a new maven project
and set its 'packaging' type to *war*.

```xml
<packaging>war</packaging>
```

Next, obviously feel free to include any dependencies you might need:

```xml
<dependencies>
  <!-- apiman dependencies (must be excluded from the WAR) -->
  <dependency>
    <groupId>io.apiman</groupId>
    <artifactId>apiman-gateway-engine-core</artifactId>
    <scope>provided</scope>
  </dependency>
</dependencies>
```

You'll want to make any apiman dependencies provided so that there aren't any classloading
conflicts when executing your code.

Finally, we recommend that you put your plugin.json file in the following location
in your maven project:

```
src/main/apiman
```

Of course, any resoures in that location are not automatially included in the final
WAR, so you should add the following markup to your pom.xml:

```xml
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-war-plugin</artifactId>
      <configuration>
        <failOnMissingWebXml>false</failOnMissingWebXml>
        <webResources>
          <resource>
            <directory>src/main/apiman</directory>
            <targetPath>META-INF/apiman</targetPath>
            <filtering>true</filtering>
          </resource>
        </webResources>
      </configuration>
    </plugin>
  </plugins>
</build>
```

This markup will ensure that resources in the *src/main/apiman* folder will be included
in the correct location in the WAR.  Also note that resource filtering is enabled,
which will make it easier to maintain your *plugin.json* file:

```json
{
  "frameworkVersion" : 1.0,
  "name" : "My Plugin Name",
  "description" : "My plugin description.",
  "version" : "${project.version}"
}
```

Note that the 'version' of the plugin is set to *${project.version}*, which will get
automatically changed to the version of your maven project at build time.

==== Making Your Plugin Available to apiman
Plugins are identified by their Maven coordinates (groupId, artifactId, version,
classifier, type).  Note that the classifier and type are optional.  If the type is
not specified when loading a plugin, apiman will assume 'war'.

When loading a plugin for use, apiman will first check for the plugin in the local
user's .m2 directory.  This is useful when running apiman during development, but
is unlikely to be available in a production environment.  If the plugin cannot be
found locally, apiman will attempt to download it from a remote repository such as
Maven Central.

TIP: You can configure additional remote repositories when you set up apiman.
Please refer to the Installation Guide for details.

This all means that when testing your plugin locally, you can simply use maven to install
it into your local .m2 directory and then ask apiman to load it.  In production, the
plugin will need to be available from a remote maven repository.

=== Contributing a Policy
Now that you know how to create an apiman plugin, you might be wondering what you can
actually do with it!  The most important purpose of a plugin is to provide additional
*Policies* that can be used when configuring Plans, APIs, and Client Apps in
apiman.  Although apiman comes with a set of useful built-in policies, it is often
necessary for users to provide their own custom policies.  The best way to do that is
to create a plugin that provides such policies.

In order to provide a custom policy from a plugin, several things are needed:

* An implementation of IPolicy (Java code)
* A policy definition (JSON file)
* An optional policy configuration form that the API Manager UI will present to the user when configuring the policy

The next few sections explain each of these elements further, but note that they are
all included in the apiman plugin WAR.

==== Policy Implementation
A policy implementation is the java code that is executed by the API Gateway when
a managed API request is made.  This is the bread and butter of the API Gateway; its
primary purpose.  For each request, the API Gateway creates a chain of policies that
must be executed before proxying the request to the back-end API implementation.
Each of the policies in that chain is an implementation of the 'IPolicy' interface.

===== Standard IPolicy
All policies must implement the `IPolicy` interface, consisting of several methods.

The `apply` method with `ApiRequest` is called during the request phase, and
the `apply` with `ApiResponse` during the response phase:

```java
void apply(ApiRequest request, IPolicyContext context, Object config, IPolicyChain<ApiRequest> chain);

void apply(ApiResponse response, IPolicyContext context, Object config, IPolicyChain<ApiResponse> chain);
```

The API objects, respectively, provide abstracted representations of the head
of a request and response for a given conversation. These can be modified in any
manner the implementor sees fit.

TIP: Policy instances are stateless, so it is not a good idea to use fields for any
reason.  The IPolicyContext can be used to pass information from the request phase
to the response phase.  Any state that must span multiple requests will need to use
one of the policy components described in the *Provided Components* section.

```java
Object parseConfiguration(String jsonConfiguration) throws ConfigurationParseException;
```

The final `IPolicy` method is used to parse JSON configuration into an arbitrary
object configuration which will be passed in in its parsed form to `doApply`, where
the implementor may cast it their native configuration object.  This method will
be invoked for each unique configuration of the policy.

For mroe information about policy configuration, see the *Policy Configuration* section
below.

====== Indicating Successes
If a policy determines that the conversation can continue, `chain.doApply` should
be signalled. Any modifications you wish to pass onto the next policy should be
completed and included in the invocation.

====== Indicating Failures
If it is determined that a conversation should be interrupted for governance reasons
(i.e. according to business logic and not exceptional), then `chain.doFailure` should
be signalled. A useful `PolicyFailure` should be provided, which allows gateways to
respond in a sensible way to the requestor.

TIP: The platform's `IPolicyFailureFactoryComponent` can be used to generate failures.
See the *Provided Components* section for more details on this component.

====== Handling Exceptions
As a factor of the asynchronous nature of apiman, any exceptions that may occur during
the operation of a policy should be caught and explicitly handed to `chain.doError`.
If exceptions are left uncaught, then it is possible that they will be lost.

===== IData Policy
Whilst standard policies are concerned only with the head of the conversation, it
is also possible for policies to access and manipulate the body in transit. A data
policy must implement the `IDataPolicy` interface.

WARNING: Handling of data streams is a performance sensitive area, implementors
should strive to be as efficient as possible and avoid any unnecessary interactions
with the stream.

The `getRequestDataHandler` and `getResponseDataHandler` methods are the data
corollaries of `apply`. Implementors must return `IReadWriteStream` streams, which
apiman uses to write data chunks into policies, and the policies write data to
subsequent policies:

```java
IReadWriteStream<ApiRequest> getRequestDataHandler(ApiRequest request, IPolicyContext context);

IReadWriteStream<ApiResponse> getResponseDataHandler(ApiResponse response, IPolicyContext context);
```

IMPORTANT: Do not return an `IApimanBuffer` with a different native type than you
received. Use assign and append patterns instead.

Implementors must explicitly hand each chunk onto apiman when they are finished
interacting with it. A convenient way to achieve this is via `AbstractStream<H>`:

```java
@Override
public IReadWriteStream<ApiRequest> getRequestDataHandler(final ApiRequest request, final IPolicyContext context) {
  return new AbstractStream<ApiRequest>() {
    @Override
    public void write(IApimanBuffer chunk) {
      // Mutate chunk by appending a string.
      chunk.append("my modification");
      // We're finished: write the chunk back to apiman
      // using super.write().
      super.write(chunk);
    }

    @Override
    public void end() {
      // End of stream signalled, do cleanup, etc.
      super.end();
    }
  };
}
```

IMPORTANT: Do not mutate an `IApimanBuffer` once handed over.

The request or response body will not begin streaming before the corresponding `doApply`
has been called, however, it is still possible to interrupt the conversation during
the streaming phase by signalling `doFailure` or `doError`.

===== Performance Considerations
Policies are amongst the most impactful elements of the system for performance. To
minimise the impact of a policy implementors may wish to follow these guidelines:

- Maintain as little state within a policy instance as possible.
- Call `doApply`, `doFailure` or `doError` as soon as possible.
- Data policies should interact with the data stream as efficiently as possible and prefer mutating in-place (especially with small changes).
- If you are contributing a policy to apiman: implement any long-running tasks asynchronously (e.g. database calls); **do not** block the main thread (e.g. blocking futures, wait, sleep); use asynchronous techniques to interact with the outside world, such as callbacks.

===== Dependencies
Typically a policy implementation should minimize the number of third party libraries
it depends on, but often times this is unavoidable.  Plugins are isolated from one
another, so it is a simple matter of including any required dependencies inside the
plugin's WAR archive in the standard location of:

```
WEB-INF/lib
```

TIP: You should make sure that any apiman dependencies you use (for example the apiman
core module that contains the IPlugin and other necessary interfaces) are marked
as 'provided' in your maven project so that they are not included in the plugin
archive.

===== Provided Components
All policy implementations have access to various resources at runtime.  These resources
are primarily accessed through the *IPolicyContext* object that is passed to the policy
when it is executed.  Along with the ability to set conversation-level attributes, the
policy context is how you access Policy Components.

A Policy Component is simply a runtime component that a policy implementation may find
useful.  To access a component, use the 'getComponent' method found on the policy
context, passing it the interface of the component you wish to use.  The following
components are available:

* *IPolicyFailureFactoryComponent*: Used to create a policy failure that is needed to call 'doFailure' on the policy chain (indicating that the policy failed).
* *ISharedStateComponent*: Used to share state information across the conversation boundary.
* *IHttpClientComponent*: Allows HTTP requests to be made from within a policy.
* *IRateLimiterComponent*: Supports standard quota/rate limiting behavior, maintaining the current number of requests.

All of the components have asynchronous APIs in order to better support the runtime
philosophy in the API Gateway.

TIP: For more information about each component, see its javadoc.

==== Policy Definition
The policy implementation is what allows the API Gateway to execute the policy at runtime.
But how does the API Manager know about the policy so that users can add it to a Plan,
API, or Client App from within the User Interface?  The answer is that the plugin
must also include a Policy Definition JSON file for each policy it is providing.

A plugin definition is a JSON file that must be located within the plugin archive
here:

```
META-INF/apiman/policyDefs
```

The plugin definition file takes the following form:

```json
{
  "id" : "policy_name",
  "name" : "Policy Name",
  "description" : "A useful description of what the policy does.",
  "policyImpl" : "plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/com.example.plugins.MyFirstPolicy",
  "icon" : "document",
  "formType" : "JsonSchema",
  "form" : "schemas/policy_name.schema"
}
```

* *id*: The unique id of the policy.
* *name*: The name of the policy.
* *description*: The description of the policy.
* *policyImpl*: Identifies the java class that implements the policy.
* *icon*: The icon to use when displaying the policy in the UI (name of a Font Awesome icon).
* *formType*: The type of form to use in the UI when configuring an instance of the policy.  See the Policy Configuration section below for details.  Valid values: _Default_, _JsonSchema_
* *form*: (_optional_) Path to a UI form that should be used when configuring an instance of the policy.  See the Policy Configuration section below for details.

The most important thing to get right in this file is probably the 'policyImpl'.  This
is the information that the API Manager will use when it tries to instantiate the
policy implementation at runtime.  For policies that come from plugins, the format
of the 'policyImpl' is:

```
plugin:{pluginGroupId}:{pluginArtifactId}:{pluginVersion}:{pluginType}/{fullyQualifiedClassname}
```

An example of what this string might look like if you cracked open a valid apiman plugin
and had a peek at one of its policy definition files is:

```
plugin:io.apiman.plugins:apiman-plugins-example:6.3.3.Final:war/io.apiman.plugins.example.ExamplePolicy
```

When building your plugin using the recommended maven configuration documented in the
*Using Maven to Create a Plugin* section, it is extremely convenient to simply let
Maven set the values for you:

```
plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/com.example.plugins.ExamplePolicy
```

==== Policy Configuration Form
You may be wondering how configuration information specific to a Plan, API, or
Client App is managed.  Since the same policy implementation instance is used for all
requests, unique configuration appropriate to a particular request must be passed to
the policy implementation when it is executed.  This configuration is created in the
API Manager user interface when adding the policy to a Plan, API, or Client App.

Policy configuration takes the form of string data that is ultimately included when
publishing an API to the API Gateway.  That string data is parsed into a Java object
via the 'parseConfiguration' on the *IPolicy* interface and then passed to the policy
during execution.

The string data is created in the API Manager user interface, either by interacting with
a Policy Configuration Form contributed by the plugin, or (if no form is included
in the plugin) by a default configuration form (a simple text area).

===== Default Policy Configuration
If the policy definition indicates that the configuration form type is *Default*, then it is
up to the UI to determine how to display configuration information.  For the policies provided
by apiman itself, there are UI forms provided.  If the policy is contributed from a plugin,
then the UI has no way to know the format of the configuration data.  In this case, a simple
TextArea is presented to the user.

WARNING: This approach is clearly not recommended, because users will likely have no idea what to
enter into the TextArea presented to them.

===== JSON Schema Policy Configuration
Alternatively, the policy definition can specify a http://json-schema.org/[JSON Schema] in
the policy definition JSON file.  For example, the policy definition might include the
following:

```json
  "formType" : "JsonSchema",
  "form" : "schemas/policy_name.schema"
```

In this case, apiman will look for a file inside the plugin artifact in the following location:

```
META-INF/apiman/policyDefs/schemas/policy_name.schema
```

The file in this location must be a JSON Schema file, which describes the JSON format of the
configuration data expected by the policy implementation.  The UI will use this JSON schema
to generate an appropriate UI form that can edit the JSON configuration data needed by the
policy implementation.

Perhaps it's best if we have an example.  The following illustrates a policy contributed from
a plugin, its JSON Schema file, the resulting form displayed in the UI, and the configuration
data format that will be passed to the policy implementation at runtime.

.META-INF/apiman/policyDefs/my-policy.json
```json
{
  "id" : "my-policy",
  "name" : "My First Policy",
  "description" : "A policy with custom configuration!",
  "policyImpl" : "plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/io.apiman.plugins.config_policy.ConfigPolicy",
  "icon" : "pie-chart",
  "formType" : "JsonSchema",
  "templates" : [
    {
      "language": null,
      "template": "Set policy with @{property1} and @{property2}!"
    }
  ],
  "form" : "schemas/config-policyDef.schema"
}
```

TIP: The templates 'language' field will support other languages in future, but
for now is null (i.e. single-language only). The template field itself is
https://github.com/mvel/mvel[MVEL] (Orb tag syntax), and displays in the UI
after a plugin has been selected by a user. 

.META-INF/apiman/policyDefs/schemas/my-policy.schema
```json
{
  "title" : "Configure My Policy",
  "description" : "Configure all of the necessary properties used by my policy.",
  "type" : "object",
  "properties": {
    "property1": {
      "title" : "Property 1",
      "type" : "string",
      "minLength" : 1,
      "maxLength" : 64
      },
    "property2": {
      "title" : "Property 2",
      "type" : "string",
      "minLength" : 1,
      "maxLength" : 64
    }
  }
}
```

.Generated UI Form
image:images/plugin-policy-config-1.png[Generated UI Form]

.JSON Configuration Data Format
```json
{
  "property1" : "USER_DATA_1",
  "property2" : "USER_DATA_2"
}
```

TIP: You can easily consume the JSON configuration data above in your policy implementation
by having your policy implementation Java class extend the `AbstractMappedPolicy` base class
provided by apiman (in the _apiman-gateway-engine-policies_ module) and creating a simple Java Bean
to hold the JSON configuration data.

First, here is the java bean used to (un)marshal the JSON configuration data.

```java
public class MyConfigBean implements Serializable {

  private static final long serialVersionUID = 683486516910591477L;

  private String property1;
  private String property2;

  /**
   * Constructor.
   */
  public MyConfigBean() {
  }

  public String getProperty1() {
    return property1;
  }

  public void setProperty1(String property1) {
    this.property1 = property1;
  }

  public String getProperty2() {
    return property2;
  }

  public void setProperty2(String property2) {
    this.property2 = property2;
  }

}
```

Now have a look at how to use that class when extending the `AbstractMappedPolicy`.

```java
public class MyPolicy extends AbstractMappedPolicy<MyConfigBean> {

  /**
   * Constructor.
   */
  public MyPolicy() {
  }

  @Override
  protected Class<MyConfigBean> getConfigurationClass() {
    return MyConfigBean.class;
  }

  @Override
  protected void doApply(ApiRequest request, IPolicyContext context, MyConfigBean config, IPolicyChain<ApiRequest> chain) {
    // Do something with MyConfigBean here?  It has all the configuration data!
    super.doApply(request, context, My, chain);
  }

  @Override
  protected void doApply(ApiResponse response, IPolicyContext context, MyConfigBean config, IPolicyChain<ApiResponse> chain) {
    // Do something with MyConfigBean here?  It has all the configuration data!
    super.doApply(response, context, config, chain);
  }

}
```

===== JSON Schema Policy Configuration SDK
If you are creating a non-trivial JSON Schema (more than just a couple of simple fields)
it can be difficult to get it right without a few iterations.  For this reason, we have
created a simple "SDK" to help you create your JSON Schema quickly.  The SDK can be found
in the apiman github repository at the following location:

```
manager/ui/war/src/main/sdk/json-schema.html
```

If you have the apiman source code checked out, you can simply open that file in your browser
and start using it to author a custom JSON Schema.

Alternatively you can use "rawgit" and just go straight to the following URL:

http://rawgit.com/apiman/apiman/master/manager/ui/war/src/main/sdk/json-schema.html

The SDK provides a way to edit your JSON schema and then see how that schema will look in
the apiman UI, as well as the format that the policy configuration data will ultimately
be in when it is sent to your policy at runtime.

TIP: Once you have the JSON Schema finalized, you could also use the online http://www.jsonschema2pojo.org/[jsonschema2pojo]
tool to generate a good starting point for a Java Bean that can be used to marshal/unmarshal your policy's configuration
data at runtime.  See the discussion about AbstractMappedPolicy above for additional information.

=== Testing a Plugin Policy
While it is quite simple to create a custom policy for apiman, you may be wondering the best way to
unit test your implementation.  Fortunately we have made this extremely easy by including an easy-to-use
Policy Testing junit framework.  Once you have followed the instructions above to create your custom
policy, refer to this section to learn how to test it using junit.

==== Import the Framework (Maven Dependency)
The first thing you will need is to include the appropriate maven dependencies in your project's
pom.xml file.  There is a single additional dependency that you will need (make sure to import it using
the 'test' maven scope):

```xml
<dependency>
   <groupId>io.apiman</groupId>
   <artifactId>apiman-test-policies</artifactId>
   <version>1.1.2-SNAPSHOT</version>
   <scope>test</scope>
</dependency>
```

==== Create and Annotate a JUnit Test Case
Once you have imported the appropriate dependency, you can go ahead and create a JUnit test case.  The
only additional thing you need is to annotate your test case appropriately and make sure your test case
Java class extends the framework's 'ApimanPolicyTest' base class.

The following annotations can then be added to your test:

* @TestingPolicy(<classname>) - indicates which of your policy implementations you wish to test
* @Configuration("<custom_policy_configuration_data>") - specifies the policy configuration to use for the test

The @TestingPolicy annotation is always placed at the class level, but the @Configuration annotation can
either be global or specified at the test method level.

These annotations tell the apiman Policy Testing framework *what* policy you want to test and the
policy configuration you want to use when testsing, but you still need to actually send requests to a
"API".  This is done using the "send(PolicyTestReqest)" method defined by the base class.  The
send() method allows you to send a request (that you build) to the mock back-end API governed by
your policy.  By default the mock back-end API is a simple "echo" API that responds to all
requests with a JSON payload describing the request it received (more on how to override this default
functionality later).

The send() method requires that you create and pass to it a valid PolicyTestRequest object.  This can
be created using the PolicyTestRequest.build() method.  You can set the request's type, resource path,
request headers, and body.  If the request is successful, then a PolicyTestResponse object will be
returned and you can perform assertions on it.  If there is a policy failure, then the send() method
will throw a PolicyFailureError.

Here is a full example of everything working together:

```java
@TestingPolicy(CustomPolicy.class)
public class CustomPolicyTest extends ApimanPolicyTest {

    @Test
    @Configuration("{}")
    public void testGet() throws Throwable {
        // Send a test HTTP request to the API (resulting in executing the policy).
        PolicyTestResponse response = send(PolicyTestRequest.build(PolicyTestRequestType.GET, "/some/resource")
                .header("X-Test-Name", "testGet"));

        // Now do some assertions on the result!
        Assert.assertEquals(200, response.code());
        EchoResponse entity = response.entity(EchoResponse.class);
        Assert.assertEquals("GET", entity.getMethod());
        Assert.assertEquals("/some/resource", entity.getResource());
        Assert.assertEquals("testGet", entity.getHeaders().get("X-Test-Name"));
        // Assert the request header that was added by the policy
        Assert.assertEquals("Hello World", entity.getHeaders().get("X-MTP-Header"));
        // Assert the response header was added by the policy
        Assert.assertEquals("Goodbye World", response.header("X-MTP-Response-Header"));
    }

}
```

==== Providing a Custom Back-End API Mock
Sometimes the echo API is not sufficient when testing your custom policy.  Perhaps the custom policy
is more tightly coupled to the API it is protecting.  In this case you may want to provide your own
custom back-end API mock implementation.  This can be done by simply annotating either the class or
an individual test method with @BackEndApi.  If you do this then you must supply the annotation with
a class that implements the IPolicyTestBackEndApi interface.  Here is an example of what this might
look like in a test:


```java
@TestingPolicy(CustomPolicy.class)
public class CustomPolicyTest extends ApimanPolicyTest {

    @Test
    @Configuration("{}")
    @BackEndApi(MyCustomBackEndApiImpl.class)
    public void testGetWithCustomBackEndSvc() throws Throwable {
        // Send a test HTTP request to the API (resulting in executing the policy).
        PolicyTestResponse response = send(PolicyTestRequest.build(PolicyTestRequestType.GET, "/some/resource")
                .header("X-Test-Name", "testGet"));

        // Now do some assertions on the result!
        MyCustomBackEndApiResponseBean entity = response.entity(MyCustomBackEndApiResponseBean.class);
    }

}
```

In this example everything works as it did before, but instead of responding with an Echo Response
the send() method will return with a custom response (as created and returned by the provided custom
back-end API implementation).


=== Contributing a Core Component
In addition to policies, the apiman plugin framework allows developers to provide custom implementations
of core apiman components.  What does this mean?  Apiman is composed of a number of different core
components, all working together to provide API Management functionality.  Both the API Gateway and 
the API Manager have core components that can be customized by providing new implementations via plugins.

Some examples of API Manager components include (but are not limited to):

* Storage Component
* Query Component
* IDM Component
* Metrics Accessor (consumes metrics data recorded by the API Gateway at runtime)

Additionally, some examples of API Gateway components include:

* Configuration Registry
* Rate Limiting Component
* Metrics Emitter (records metrics data for each request)

By default, the apiman quickstart uses default values for all of these, resulting in a stable, working 
system with the following characteristics:

* Stores API Manager data in a JDBC database
* Records and queries metrics data via Elasticsearch
* Stores Gateway configuration information in Elasticsearch
* Uses Elasticsearch to share rate limiting state across gateway nodes

However, if you wish to provide a custom implementation of something, you can implement the appropriate
Java interface for the correct component, bundle the implementation up into a plugin, and then tell
apiman to use yours instead of the default.

==== Implementing a Custom Core Component
The procedure for creating a plugin to hold your custom component is exactly the same as already 
described in the *Creating a Plugin* section above.  Once you have created your plugin, including
a custom implementation of a core component is simply a matter of creating a Java class that 
implements the appropriate component interface.

Let's try an example.

By default, apiman stores API Gateway configuration in Elasticsearch.  The component responsible
for this is called ESRegistry, and it implements this interface:

```java
package io.apiman.gateway.engine;

public interface IRegistry {

    public void getContract(ApiRequest request, IAsyncResultHandler<ApiContract> handler);

    public void publishApi(Api api, IAsyncResultHandler<Void> handler);
    
    public void retireApi(Api api, IAsyncResultHandler<Void> handler);
    
    public void registerClient(Client client, IAsyncResultHandler<Void> handler);

    public void unregisterClient(Client client, IAsyncResultHandler<Void> handler);

    public void getApi(String organizationId, String apiId, String apiVersion, IAsyncResultHandler<Api> handler);

}
```

Perhaps you'd rather store the API Gateway configuration information into mongodb instead of 
Elasticsearch.  Since we don't support a mongodb registry, you would need to implement your own
and contribute it via a plugin.  Simple create a new plugin and include in it the following 
Java class:

```java
package org.example.apiman.plugins;

public class MongoDbRegistry implements IRegistry {

    public MongoDbRegistry(Map<String, String> config) {
        // TODO consume any config params - these come from apiman.properties
    }

    public void getContract(ApiRequest request, IAsyncResultHandler<ApiContract> handler) {
        // TODO implement mongodb specific logic here
    }

    public void publishApi(Api api, IAsyncResultHandler<Void> handler) {
        // TODO implement mongodb specific logic here
    }
    
    public void retireApi(Api api, IAsyncResultHandler<Void> handler) {
        // TODO implement mongodb specific logic here
    }
    
    public void registerClient(Client client, IAsyncResultHandler<Void> handler) {
        // TODO implement mongodb specific logic here
    }

    public void unregisterClient(Client client, IAsyncResultHandler<Void> handler) {
        // TODO implement mongodb specific logic here
    }

    public void getApi(String organizationId, String apiId, String apiVersion, IAsyncResultHandler<Api> handler) {
        // TODO implement mongodb specific logic here
    }

}
```

TIP: While optional, it is often useful to provide a constructor that takes a map of configuration
params.  These values comes from the *apiman.properties* and is an arbitrary set of keys/values.  It
can be extremely helpful when, for example, configuring the mongodb connection information.

==== Enabling Your Custom Component
Now that you have a custom component built and included in a plugin, you will need to make sure
that the plugin is available to your server.  You can do this by deploying the plugin artifact
to a maven repository and then making that repository available to apiman by adding its URL to 
the following property in *apiman.properties*:

```
apiman.plugins.repositories=http://repository.jboss.org/nexus/content/groups/public/
```

Simply add your organization's maven repository to that (the value can be a comma separated list of
URLs).

Alternatively, you can make sure your plugin is installed in the ".m2" directory on the machine
that is running your server.  Obviously you can use "mvn install" to accomplish this.

Next, simply enable the custom component implementation by updating your *apiman.properties* file
like this (for example):

```
apiman-gateway.registry=plugin:GROUP_ID:ARTIFACT_ID:VERSION/org.example.apiman.plugins.MongoDbRegistry
apiman-gateway.registry.mongo.host=localhost
apiman-gateway.registry.mongo.port=27017
apiman-gateway.registry.mongo.username=sa
apiman-gateway.registry.mongo.password=sa123!
apiman-gateway.registry.mongo.database=apiman
```

The most important part above is the format for the registry itself.  It might look something like
this:

```
apiman-gateway.registry=plugin:org.example.apiman-plugins:plugin-mongodb:1.0.0.Final/org.example.apiman.plugins.MongoDbRegistry
```

Finally, the set of properties prefixed with "apiman-gateway.registry" will be processed and passed
to your *MongoDbRegistry* class's *Map* constructor if one is provided.  The map that is passed to
the constructor will contain the following:

```
mongo.host=localhost
mongo.port=27017
mongo.username=sa
mongo.password=sa123!
mongo.database=apiman
```
